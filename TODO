crear un dockerfile para ejecutar el proyecto
Loggeer event
limpiar
CLI:
FLAG PARA CAARGAR VS ENTRAR
Daemon:
Hacerlo que sea 100% deatach
Mutuo:
executor (advance)

DONE:
Shell like terminal
Protocolo basico
Mirar señales y go
Estructuras terminadas y con defaults
Lector de archivos de configuración y lo guarde en una estructura
Ver como funciona supervisor
Mirar go y yaml
Cambiar a yaml desde xml
enviar y reccibir, broadcast desde el server
Recivir info desde el daemon
Establecer un protocolo (idea, cmd + contenido)
Diseñar comandos
SIGHUP para recargar config
Settear wrapper the cmds


----> PABLETO PARTE <----
Executor:

✅ Options to discard the program’s stdout/stderr or to redirect them to files
✅ Environment variables to set before launching the program
✅ A working directory to set before launching the program
✅ An unmask to set before launching the program (check)
Whether to start this program at launch or not

Upper manager:
- Whether the program should be restarted always, never, or on unexpected exits only
- Which return codes represent an "expected" exit status
- How long the program should be running after it’s started for it to be considered "successfully started"





Hasta ahora lo que hemos hecho son un manager que tiene profiles (cada archivo de configuracion)
Solo tiene que inicializar un Task para un executor.
La idea es que cada task tenga toda la configuracion de un proceso a ejecutar!
Hecho esto habria que testear y empezar con las tareas pendientes de arriba!
listas procesos, perfiles... cargarse un perfil... Y UN VIGILANTE! <-


prompt del Vigilante:
Constantly watches running processes - monitoring their state, health, and behavior

Reports with Vigilante-style commentary - things like:
"Dude, seriously? Process nginx just crashed AGAIN!"
"I'm watching you, process worker-1... don't even THINK about dying on me"
"Process api-server has been running for 3 hours straight. Respect."
"Oh great, process database is using 95% CPU. That's just PERFECT."
"Process cache-server stopped responding. Time to take out the trash."

Triggers restart policies - when it detects a process has died or is misbehaving, it would:
Check the restart policy (always/never/on-unexpected-exits)
Verify exit codes against expected values
Enforce the "successfully started" time threshold
Coordinate with the Executor to restart if needed
Maintains vigilance logs - keeping track of:
Process uptime
Restart counts
Health check results
Resource usage anomalies

The Vigilante would sit between your Manager and Executors, constantly polling or receiving events about process state changes, and making decisions about what actions to take - all while providing sarcastic, Vigilante-style status updates in the logs.


manager has:
profiles
each profile has an Executor pointer containing all executions
Executor could have all the data about:
- should be restarted?
- Which signal does it stop it?
- Options to discard the program’s stdout/stderr or to redirect them to files
- Environment variables to set before launching the program
- A working directory to set before launching the program
- An unmask to set before launching the program
- Whether to start this program at launch or not (?)
